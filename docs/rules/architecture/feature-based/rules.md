# feature-based Architecture - 実装ルール

このドキュメントは、feature-based Architecture を採用した場合の LLM 向け実装ルールとチェックリストを定義します。

## コア実装ルール

### 1. ファイル構成の原則

#### ✅ 必須ルール

- **1 機能 1 ファイル**: 各機能は独立したファイルに実装する
- **ディレクトリ完結性**: 外部ディレクトリへの依存は最小限に抑える
- **明確な命名**: ファイル名は機能を明確に表現する（例: `create-todo.ts`, `send-email.ts`）

#### ❌ 禁止事項

- 複数の機能を 1 つのファイルに混在させない
- 不必要な抽象化レイヤーを作らない
- 将来の拡張性のための事前設計をしない

### 2. ディレクトリ構造

```
src
├── __tests__
|  ├── e2e              # E2Eテスト
|  └── integration      # インテグレーションテスト
├── app
|  ├── api              # APIルート
|  ├── layout.tsx
|  ├── page.tsx
|  ├── global.css       # グローバルなスタイル定義
|  └── provider.tsx     # プロバイダーを一元管理
├── components
|  ├── layout           # 各ページで使用される共通レイアウト
|  └── ui               # 全体に共有されるUIコンポーネント
├── features            # 機能ごとのコンポーネント・ロジック
|  ├── {feature-name}
│  |   ├── actions      # ユーザーアクション、フォーム送信、CRUD
│  |   ├── api          # 外部システムとの連携、コールバック
│  |   ├── components   # exportされる本体
│  |   ├── hooks        # 機能内で共有されるフック
│  |   ├── types        # 機能内で共有される型
│  |   └── index.ts     # Componentsのみexport
|  └── ...
├── hooks               # アプリ内で共有されるライブラリに依存しないカスタムフック
├── lib                 # 外部ライブラリの初期化設定や固有のカスタムフックなど
├── stores              # 全体で共有される状態管理
├── types               # 型定義を一元的に管理する
└── utils               # アプリ内で共有されるライブラリに依存しないユーティリティ

```

### 3. ファイル内の構造

各機能ファイルは以下の順序で構成する：

```typescript
// 1. インポート
import { z } from 'zod'
import { database } from '../../lib/database'

// 2. 型定義・スキーマ
const InputSchema = z.object({...})
type Output = {...}

// 3. 内部ヘルパー関数
function validateBusinessRule(...) {...}

// 4. メイン処理関数
export const mainFunction (input: unknown) {
  // 実装
}

```

---

## 実装ガイドライン

### 新機能を追加する時

1. **機能の粒度を決定**

   - 1 つのビジネスアクション = 1 ファイル
   - 例: "Todo を作成する" = `create-todo.tsx`

2. **ディレクトリを作成**

   ```bash
   mkdir -p src/features/[feature-name]/components
   ```

   - 外部への export は必ず`{feature-name}/components`から行う

3. **ファイルを作成**
   - アクション名を明確にしたファイル名を使用
   - ケバブケース（kebab-case）を使用

### ユニットテストの配置

```
todo
├── create-todo.ts
├── create-todo.test.ts    # 同じディレクトリに配置
└── ...
```

---

## 各ディレクトリの運用ルール

### `app/`:Next.js App Router + API Routes に従った構造

- `app/page.tsx`：`components/`や`features/`からエクスポートされたコンポーネントで構成され純粋にコンポーネント組み立てに集中する
- `app/provider.tsx`：各プロバイダーはここで一元管理する

### `components/`:アプリ全体で共有される UI コンポーネント

- `components/layout/`:各ページで使える共通レイアウト
- `components/ui/`：Button, Dialog, Tooltip などの汎用部品コンポーネント

### `features/`:特定のドメインに基づく機能

- 外部へのエクスポートはコンポーネントのみを行う
- ロジックの外部エクスポートは禁止する
- 他 features からなどからデータが必要な場合、直接インポートはせず`stores/`を経由する
- ライブラリは直接インポートせず`lib/`で初期設定・ラッパー化されたもの使用する

**stores/との連携について**

`features/{feature-name}/api/`でデータフェッチをする際や複数機能に影響する`features/{feature-name}/hooks/`（use-theme など）は、相当する`/stores`を同時に用意して、外部からは`/stores`経由でのみ利用すること
これによって責務を分離しつつ、データの連携・複合機能の構築が行える

### `hooks/`:ライブラリに依存しないカスタムフック

- 汎用的に使えるカスタムフック
- **外部ライブラリに依存する場合は`lib/`に配置**する

### `lib/`:外部ライブラリの設定・ラッパー

- ライブラリごとにファイルを分ける（`lib/{library-name}.ts`）
- 肥大化して分割する場合ディレクトリ`lib/{library-name}`を切る
- 固有の型やカスタムフックを含んでエクスポートしても良い

**自前のロジックは禁止**

- 外部ライブラリに依存しない自前のロジックを置くことは禁止する
- use-mobile.tsx(画面サイズがモバイルの時の処理)などのカスタムフックであれば`hooks/`、texts.ts（文字に関する処理）などの純粋関数であれば`utils/`が適切

### `stores/`:グローバルに共有される状態

- API から取得されたデータなど、複数の機能やコンポーネントで使用される状態を一元管理する
- 単一機能でのみ使用される場合は、その機能内で状態管理することを優先する
- 機能関心ごと、あるいは API エンドポイントごとのファイル名とする（`stores/user.ts`、`stores/post.ts`）
- 複数の状態を合成・計算した新たな状態を作っても良い

#### **_状態の合成・計算での新たな状態について_**

例えば報酬までの残り目標ポイント数を定義したい場合、`stores/rewards.ts`と`stores/points.ts`からインポートした`stores/target-points.ts`を作って、`/features/rewards`で使用しても良い
このような合成状態は、複数の基底状態から派生する計算済み状態として扱う

### `types/`: アプリ全体で共通する型定義

- 型安全・重複排除を目的としてアプリ内で使う型を一元管理する
- 機能名(`types/user.ts`など)で分類する

### `utils/`:ライブラリに依存しないユーティリティ

- 純粋関数ベース
- **外部ライブラリに依存する場合は`lib/`に配置**する

---

## LLM 向け実装チェックリスト

### 実装前の確認事項

- [ ] 機能の範囲が 1 つのビジネスアクションに限定されている
- [ ] ファイル名が機能を明確に表現している
- [ ] 既存の関連機能のパターンを確認済み
- [ ] テストファイルの配置場所を決定済み

### 実装中のチェックポイント

- [ ] 全ての処理が 1 ファイル内で完結している
- [ ] 外部ファイルへの依存が最小限
- [ ] エラーハンドリングがファイル内で完結
- [ ] バリデーションロジックが組み込まれている

### 実装後の確認事項

- [ ] テストカバレッジが 70%以上
- [ ] テストが他のテストに依存していない
- [ ] 機能が完全に動作する
- [ ] コードが理解しやすい構造になっている

## アンチパターン

### ❌ 避けるべきパターン

1. **過度な抽象化**

   ```typescript
   // 悪い例: 不必要なインターフェース
   interface TodoService {
     create(dto: CreateTodoDto): Promise<Todo>;
   }

   class TodoServiceImpl implements TodoService {
     constructor(private repository: TodoRepository) {}
   }
   ```

2. **レイヤー分割**

   ```typescript
   // 悪い例: レイヤーに分割
   // controllers/todo.controller.ts
   // services/todo.service.ts
   // repositories/todo.repository.ts
   ```

3. **早すぎる最適化**
   ```typescript
   // 悪い例: 将来の拡張を見越した設計
   abstract class BaseHandler<T, R> {
     abstract validate(input: T): void;
     abstract execute(input: T): Promise<R>;
   }
   ```

## ベストプラクティス

### 1. シンプルさを保つ

- 最初は全てをファイル内に書く
- 必要になってから共通化する
- YAGNI の原則を徹底する

### 2. 読みやすさを優先

- 1000 行のファイルでも、論理的に整理されていれば OK
- コメントで区切りを明確にする
- 関数は小さく保つ

### 3. テストファースト

- 機能を実装する前にテストを書く
- テストも同じファイル構造で管理
- モックは最小限に

## LLM 向け実装指針

### 新機能実装時のフロー

1. **機能ディレクトリ確認**: 該当する機能のディレクトリを確認
2. **パターン確認**: 既存コードがある場合はそのパターンに従う
3. **自己完結実装**: 1 ファイルで完結するよう実装
4. **テスト作成**: 同じディレクトリにテストファイルを作成

### リファクタリング時の優先順位

1. **ファイル内改善**: 1 つのファイル内での改善を優先
2. **最小限のファイル間変更**: ファイルを跨いだ変更は最小限に
3. **3 回ルール**: 共通化は実際に 3 回以上重複してから検討

### 判断基準（迷った時の優先順位）

1. **シンプルさを選ぶ** - 複雑な設計より単純な解決策
2. **独立性を選ぶ** - ファイル間依存より自己完結
3. **1 ファイル完結を選ぶ** - 分割より統合

### エスカレーション基準

以下の場合はユーザーに確認：

- 当初想定範囲の明らかな超過
- アーキテクチャレベルの変更
- 新しい依存関係の追加
- パフォーマンスに大きな影響を与える変更

## まとめ

このアーキテクチャは、LLM が最も効率的に作業できるよう設計されています。人間にとっては冗長に見えるかもしれませんが、LLM にとっては最も理解しやすく、修正しやすい構造です。

**覚えておくべき一言：「迷ったら分割せず、1 ファイルに書く」**
