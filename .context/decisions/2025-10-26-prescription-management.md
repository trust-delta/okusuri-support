# 決定記録: 処方箋管理機能の導入

**日付**: 2025年10月26日
**ステータス**: 承認済み
**決定者**: 開発者

---

## 背景

服薬記録履歴の統計機能を実装する過程で、以下の課題が明らかになった：

1. **未記録日の扱い**: レコードが全くない日をどう扱うかが不明確
2. **期待値の計算**: 「その日に服用すべきだった薬」を正確に把握できない
3. **薬の変更への対応**: 月の途中で薬が追加・削除された場合、統計が不正確になる

### 現在の実装の問題点

```typescript
// 現在：isActiveな薬のタイミング数 × 月の全日数
期待値 = 現在アクティブな薬のタイミング数 × 月の日数
```

この方法では：
- 10月1日に薬を追加 → 10月全体（31日分）の期待値に含まれてしまう
- 10月15日に薬を削除 → 10月1-14日の期待値から除外されてしまう
- 過去の統計が薬の現在の状態に依存してしまう

---

## 決定

### 処方箋管理機能を導入し、薬の有効期間を明示的に管理する

処方箋（prescription）を新しいエンティティとして追加し、薬と期間を紐付ける。

---

## 理由

### 1. ドメインモデルとして自然

実際の服薬管理のフローに即している：

```
医師が処方箋を発行（開始日・終了日あり）
  ↓
患者が処方箋に基づいて薬を登録
  ↓
期間内でスケジュール通りに服薬記録
  ↓
統計を見る（処方箋の期間に基づく正確な計算）
```

### 2. 統計計算のロジックが明確

```typescript
// 処方箋ベース（明確）
期待値 = その日に有効な処方箋に含まれる薬のタイミング数

// 具体例：
// 10/1-10/14: 処方箋A（薬3種、1日4回） → 期待値 12回/日
// 10/15-10/31: 処方箋B（薬2種、1日3回） → 期待値 6回/日
```

### 3. データの整合性

- 過去の統計は常に正確（処方箋データが残っている限り）
- 薬の追加・削除が統計に正しく反映される
- 将来の予定（例：1週間後から新しい薬）を事前登録できる

### 4. 将来の拡張性

処方箋情報を持つことで、以下の機能が実装しやすくなる：
- 処方箋の画像管理
- 薬局・医療機関との連携
- 薬の在庫管理（処方箋の期間から計算）
- 処方箋の更新通知

---

## 利点

✅ **正確な統計**: 期間ごとの期待値を正確に計算できる
✅ **自然なフロー**: 実際の服薬管理の流れに即している
✅ **データの整合性**: 過去の統計が薬の現在の状態に影響されない
✅ **拡張性**: 処方箋に関連する追加機能を実装しやすい
✅ **ユーザー理解**: 処方箋という概念は医療ドメインで一般的

---

## 欠点

❌ **初期実装コスト**: スキーマ追加、UI実装、既存コードの修正が必要
  → **対応**: 段階的に実装（最小限のスキーマから開始）

❌ **UXの複雑化**: ユーザーが処方箋と薬の関係を理解する必要がある
  → **対応**: わかりやすいUI/UXデザイン、適切なオンボーディング

❌ **既存データの移行**: 開発段階だが、テストデータの再作成が必要
  → **対応**: 現在は開発段階なので影響は最小限

---

## 代替案

### 1. 自動的な期間管理（inactivatedAtの追加）

```typescript
medicines: {
  createdAt: v.number(),
  inactivatedAt: v.optional(v.number()),
}
```

**メリット**:
- 実装が簡単
- UIの変更が最小限

**デメリット**:
- 薬単位の管理で、処方箋という概念がない
- 将来の予定（事前登録）ができない
- ドメインモデルとして不自然

**却下理由**: 処方箋機能は今後予定されており、今実装する方が自然

### 2. レコードベースの期待値計算

実際にレコードが存在する日のみを基準に統計を計算。

**メリット**:
- 実装が非常にシンプル

**デメリット**:
- レコードが全くない日は計算できない
- 「服薬すべきだった日」という概念が失われる
- 服用率の意味が曖昧になる

**却下理由**: 服薬管理アプリとして本質的な機能を失う

---

## 実装計画

### フェーズ1: 最小限のスキーマ実装 ✅

```typescript
prescriptions: defineTable({
  groupId: v.id("groups"),
  name: v.string(),                    // 処方箋名（例：「10月分の処方箋」）
  startDate: v.string(),               // YYYY-MM-DD
  endDate: v.optional(v.string()),     // YYYY-MM-DD（未指定 = 継続中）
  notes: v.optional(v.string()),
  createdBy: v.string(),
  createdAt: v.number(),
  updatedAt: v.number(),
})
.index("by_groupId", ["groupId"])
.index("by_groupId_startDate", ["groupId", "startDate"]);
```

### フェーズ2: 薬との紐付け

```typescript
medicines: {
  prescriptionId: v.id("prescriptions"),
  // ... 既存フィールド
}
```

### フェーズ3: 統計計算ロジックの変更

`getMonthlyStats` を処方箋ベースの計算に変更：
- その月の各日付について、有効な処方箋を取得
- 処方箋に含まれる薬のタイミング数を集計
- 日別・月別の期待値を計算

### フェーズ4: UI実装

- 処方箋登録ページ
- 処方箋一覧ページ
- 薬登録時の処方箋選択
- 既存の薬追加UIの修正

### フェーズ5: 既存データの移行（開発段階）

- テストデータの再作成
- デフォルト処方箋の自動生成（オプション）

---

## 技術的考慮事項

### 1. 期間の重複

同じグループで複数の処方箋が同時に有効な場合：
- **許可する**: 複数の処方箋を並行して管理できる（柔軟性）
- **禁止する**: 期間の重複チェックを実装（シンプル）

→ **決定**: 初期は許可する（柔軟性を優先）

### 2. 処方箋なしの薬

移行期間中、処方箋に紐付かない薬が存在する可能性：
- **対応**: `prescriptionId` を optional にする
- 処方箋なしの薬は「デフォルト処方箋」として扱う

### 3. 統計計算のパフォーマンス

処方箋データが増えると、統計計算が複雑になる：
- **対応**:
  - インデックスの最適化（by_groupId_startDate）
  - 必要に応じてキャッシュを導入

---

## 関連ドキュメント

- [プロジェクト概要](../project.md)
- [アーキテクチャ](../architecture.md)
- [服薬記録機能仕様](../specs/features/medication.md)
- [服薬記録履歴機能仕様](../specs/features/medication-history.md)

---

## 承認

| 役割 | 名前 | 日付 |
|------|------|------|
| 提案者 | AI | 2025-10-26 |
| レビュー | 開発者 | 2025-10-26 |
| 承認者 | 開発者 | 2025-10-26 |

---

## 次のステップ

1. ✅ 決定記録作成（このドキュメント）
2. ⏳ ユーザーによるレビューと承認
3. ⏳ 処方箋スキーマの実装
4. ⏳ 統計計算ロジックの変更
5. ⏳ UI実装
6. ⏳ テストデータの再作成

---

## 更新履歴

### 2025年10月26日 - 処方箋削除の一貫性改善（削除は常に論理削除に統一）

#### 背景

現在の削除機能では、削除操作の挙動が記録の有無によって異なっていた：
- **記録がある場合**: 論理削除（ゴミ箱に移動、復元可能）
- **記録がない場合**: 物理削除（完全に削除、復元不可）

この設計には以下の問題がありました：

1. **予測不可能性**: ユーザーは削除の結果を事前に予測できない
2. **一貫性の欠如**: 同じ「削除」操作で異なる結果が生じる
3. **誤操作のリスク**: 物理削除されてしまうと復元できない
4. **UI/UXの直感性の問題**: 同じボタンで挙動が異なるのは直感的ではない

#### 実装内容

**1. 削除機能の変更**

`deletePrescription` mutation を変更：
- **変更前**: 記録の有無で論理削除と物理削除を切り替え
- **変更後**: 常に論理削除に統一
- 全ての処方箋がゴミ箱に移動し、復元可能な状態になる

**2. 完全削除機能の追加**

`permanentlyDeletePrescription` mutation を新規作成：
```typescript
{
  args: {
    prescriptionId: Id<"prescriptions">,
  },
  handler: async (ctx, args) => {
    // 論理削除済みの処方箋のみを対象
    // 処方箋、medicines, schedules, records を物理削除
  }
}
```

**特徴**:
- 論理削除済みの処方箋のみを対象（削除されていない処方箋にはエラー）
- 二重確認ダイアログで警告を表示
- 関連する全データを物理削除（取り消し不可）

**3. UI の改善**

ゴミ箱に「完全削除」ボタンを追加：
- 赤色のゴミ箱アイコン
- 警告メッセージ付きの二重確認ダイアログ
- 復元ボタンとは明確に区別

#### ユーザー体験の改善

✅ **一貫性**: 削除操作は常に同じ挙動（論理削除）
✅ **安全性**: 誤削除からの復元が常に可能
✅ **明確性**: 完全削除は別の明示的な操作
✅ **予測可能**: ユーザーは結果を予測できる

#### データ整合性の保証

- 削除（論理削除）: 全てのデータが保持され、復元可能
- 完全削除: 全ての関連データを物理削除、復元不可

#### 更新されたファイル

- `convex/medications/prescriptions/mutations.ts` - deletePrescription変更、permanentlyDeletePrescription追加
- `app/(private)/prescriptions/_components/DeletedPrescriptionList.tsx` - 完全削除ボタン追加
- `.context/specs/features/medication.md` - 仕様書更新
- `.context/decisions/2025-10-26-prescription-management.md` - 決定記録更新

---

### 2025年10月26日 - 処方箋の無効化機能の実装

#### 背景

論理削除・復元機能の実装後、以下の課題が明らかになった：

1. **継続中の処方箋を終了させる方法が不明確**
   - 終了日を指定せずに作成した処方箋が「継続中」のままになる
   - 処方が変わった際に、削除以外の方法で無効化できない

2. **削除と無効化の役割が混在**
   - 削除は「誤って作成した処方箋」を取り消す操作
   - 無効化は「処方が終わった・変わった」ことを記録する操作
   - これらを明確に分離する必要がある

3. **期限切れの処方箋が一覧に残り続ける**
   - `endDate` を過ぎた処方箋も一覧に表示され続ける
   - 長期的に不便

#### 実装内容

**1. 処方箋の無効化・有効化機能**

新しい mutation を追加：
- `deactivatePrescription`: `isActive` を `false` に設定
- `activatePrescription`: `isActive` を `true` に設定

**2. 終了日設定のUI追加**

継続中（`endDate` 未設定）の処方箋に終了日を設定できるUIを追加。

**3. フィルタ機能の追加**

処方箋一覧に以下のフィルタを追加：
- **有効期間内**：`startDate <= 今日 <= endDate` かつ `isActive = true`
- **期限切れ**：`endDate < 今日` または `isActive = false`
- **すべて**：全ての処方箋（論理削除以外）

**4. 有効な薬剤取得クエリの更新**

`getActiveMedicationsForDate` で `isActive = true` のチェックを追加し、無効化された処方箋の薬は新規記録の選択肢に表示されないようにする。

#### データ整合性の保証

- **無効化された処方箋**：
  - 既存の服薬記録は保持される（統計も正確）
  - 新規の服薬記録は作成できない

- **削除との違い**：
  - **無効化**：`isActive = false`、記録は見える、新規作成不可
  - **論理削除**：`deletedAt` をセット、記録も見えなくなる、ゴミ箱から復元可能

#### ユーザー体験の改善

- 処方が終わった際に「無効化」ボタンで簡単に処理できる
- 誤って無効化した場合は「有効化」で元に戻せる
- フィルタで期限切れの処方箋を非表示にできる
- 削除と無効化の役割が明確になる

### 2025年10月26日 - 論理削除・復元機能の実装完了

#### 実装内容

**1. 論理削除フィールドの追加**

全ての medication 関連テーブルに以下のフィールドを追加：
```typescript
deletedAt?: number,    // 論理削除日時
deletedBy?: string,    // 削除者のユーザーID
```

対象テーブル：
- `prescriptions`
- `medicines`
- `medicationSchedules`
- `medicationRecords`

**2. 削除機能の実装**

`deletePrescription` mutation：
- 紐付く服薬記録が存在する場合：論理削除（削除日時を記録）
- 紐付く服薬記録が存在しない場合：物理削除
- 論理削除時は関連データ（medicines, schedules, records）も全て論理削除
- 既に削除済みの処方箋の再削除を防止

**3. クエリフィルタの追加**

全てのクエリに論理削除フィルタを追加：
```typescript
.filter((q) => q.eq(q.field("deletedAt"), undefined))
```

対象ファイル：
- `convex/medications/prescriptions/queries.ts`
- `convex/medications/prescriptions/helpers.ts`
- `convex/medications/records/queries.ts`

**4. 復元機能の実装**

`restorePrescription` mutation：
- `deletedAt`, `deletedBy` を `undefined` に戻す
- 関連データ（medicines, schedules, records）も全て復元
- 既に復元済みの処方箋の再復元を防止

**5. ゴミ箱UI の実装**

処方箋管理画面にタブUIを追加：
- 「有効な処方箋」タブ：通常の処方箋一覧
- 「ゴミ箱」タブ：削除された処方箋一覧

`DeletedPrescriptionList` コンポーネント：
- 削除された処方箋を一覧表示
- 削除日時の表示
- 復元ボタン（緑色の回転矢印アイコン）
- 削除済みバッジ（赤色）

**6. クエリAPI の追加**

```typescript
// 削除された処方箋を取得
getDeletedPrescriptions: query({
  args: { groupId: Id<"groups"> },
  returns: Array<Prescription>
})
```

#### 実装ファイル

- `convex/medications/prescriptions/queries.ts` - クエリにフィルタ追加、削除済み処方箋取得追加
- `convex/medications/prescriptions/helpers.ts` - ヘルパー関数にフィルタ追加
- `convex/medications/prescriptions/mutations.ts` - 削除チェック追加、復元mutation追加
- `convex/medications/records/queries.ts` - クエリにフィルタ追加
- `app/(private)/prescriptions/page.tsx` - タブUI追加
- `app/(private)/prescriptions/_components/DeletedPrescriptionList.tsx` - ゴミ箱UI新規作成
- `app/_shared/components/ui/tabs.tsx` - shadcn/ui tabs コンポーネント追加

#### データ整合性の保証

- 論理削除されたデータは通常のクエリから除外
- 削除された処方箋に紐付く記録も全て非表示
- 復元時は関連データも全て同時に復元
- 過去の統計は論理削除の影響を受けず正確に保持

#### ユーザー体験

- 誤って削除した処方箋を簡単に復元可能
- ゴミ箱から復元ボタンをクリックするだけ
- 削除日時を確認できる
- データを完全に失うリスクが低減

#### 実装状況

✅ フェーズ1: 最小限のスキーマ実装
✅ フェーズ2: 薬との紐付け
✅ フェーズ3: 統計計算ロジックの変更
✅ フェーズ4: UI実装
✅ フェーズ5: 論理削除・復元機能の実装 ← **NEW**

---

---

### 2025年10月26日 - デフォルト処方箋の自動作成機能

#### 背景

処方箋管理機能の実装後、以下の課題が明らかになった：

1. **初心者ユーザーの障壁**: 処方箋の概念を理解していないユーザーは、すぐに服薬記録を始められない
2. **初期設定の手間**: グループ作成後、まず処方箋を登録してから薬を追加する必要があり、手順が多い
3. **空の状態問題**: 新規グループでは何も表示されず、次に何をすればいいか分かりにくい

#### 決定

グループ作成時に自動的にデフォルト処方箋「日常の薬」を作成する。

**デフォルト処方箋の内容**:
- 処方箋名: 「日常の薬」
- 開始日: グループ作成日
- 終了日: 未設定（継続中）
- 含まれる薬:
  - 朝の薬（朝タイミング）
  - 昼の薬（昼タイミング）
  - 晩の薬（晩タイミング）
  - 就寝前の薬（就寝前タイミング）

#### 理由

1. **即座に使える**: 処方箋管理を理解する前でも、すぐに服薬記録を開始できる
2. **学習コスト削減**: デフォルト処方箋を見ることで、処方箋の概念を理解しやすくなる
3. **柔軟性**: 不要なら削除でき、編集も自由にできる
4. **実装がシンプル**: グループ作成時に1回だけ実行するロジックで済む

#### 実装内容

**ヘルパー関数の追加**:
- `convex/medications/prescriptions/helpers.ts` に `createDefaultPrescription` 関数を追加
- グループ作成時に自動的に呼び出す

**変更箇所**:
1. `convex/groups/mutations.ts` の `createGroup`
2. `convex/groups/mutations.ts` の `completeOnboardingWithNewGroup`

#### ユーザー体験の改善

✅ **即座に利用可能**: グループ作成直後から服薬記録を開始できる
✅ **学習しやすい**: デフォルト処方箋を見て、処方箋の使い方を学べる
✅ **柔軟性**: 不要なら削除、必要なら編集可能
✅ **オンボーディング改善**: 初回ユーザーの離脱を防ぐ

#### 注意事項

- デフォルト処方箋は一度だけ作成される（削除後は再作成しない）
- 特別なフラグは設けず、通常の処方箋として扱う
- ユーザーの意思を尊重（削除されたら再作成しない）

---

## 結論

処方箋管理機能の導入により、服薬記録の統計計算が正確になり、データの整合性が向上しました。論理削除・復元機能により、ユーザーの誤操作からのリカバリーが可能になり、安心して使えるシステムとなりました。デフォルト処方箋の自動作成により、初心者ユーザーでもすぐに服薬記録を開始できるようになりました。

今後は、以下の機能拡張が考えられます：
- 処方箋の編集機能
- 処方箋の画像アップロード機能
- 薬局・医療機関との連携
- 薬の在庫管理
- 処方箋の更新通知
