# 多層防御

複数の重複するセキュリティ層により、1つが失敗しても他が保護を継続します。

## 層の構成

```
┌─────────────────────────────────────────────────────────┐
│  層1: クライアントサイド（UX のみ、セキュリティではない）│
│  - フォーム検証、無効化されたボタン                      │
│  - ユーザーフィードバックを提供、偶発的エラーを防止      │
│  - この層をセキュリティとして信頼しない                  │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│  層2: API ゲートウェイ / エッジ                          │
│  - レート制限                                            │
│  - CORS、CSP ヘッダー                                    │
│  - 認証トークン検証                                      │
│  - 基本的な入力サニタイズ                                │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│  層3: アプリケーションロジック                           │
│  - 認可チェック（このユーザーはこれを行えるか？）        │
│  - ビジネスルール検証                                    │
│  - スキーマによる入力検証（Zod など）                    │
│  - リソース所有権の確認                                  │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│  層4: データアクセス層                                   │
│  - パラメータ化クエリ（SQLインジェクション防止）         │
│  - RLS ポリシー (Supabase) / Security Rules (Firebase)  │
│  - データアクセス前の最終認可チェック                    │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│  層5: データベース                                       │
│  - 保存時の暗号化                                        │
│  - ネットワーク分離                                      │
│  - 監査ログ                                              │
└─────────────────────────────────────────────────────────┘
```

## なぜ複数の層が必要か？

### 単一障害点

```typescript
// ❌ 1つのチェック、1つの障害点
export async function deleteAccount(userId: string) {
  // この1つのチェックにバグがあれば終わり
  if (session.userId === userId) {
    await db.users.delete(userId);
  }
}

// ✅ 複数の独立したチェック
export async function deleteAccount(userId: string) {
  // 層1: 認証ミドルウェアがすでにセッションを検証
  const session = await requireAuth();  // 未認証なら例外をスロー

  // 層2: アプリケーションロジックチェック
  if (session.userId !== userId) {
    throw new Error("アクセス拒否");
  }

  // 層3: データベースレベルのチェック（RLS など）
  // 上記チェックが失敗しても、DB は他ユーザーのデータを許可しない
  await db.users.delete(userId);  // RLS: auth.uid() = id

  // 層4: フォレンジック用の監査ログ
  await auditLog.record("account_deleted", { userId, by: session.userId });
}
```

### 異なる失敗モード

各層は異なるタイプの攻撃をキャッチ:

| 攻撃 | クライアント | ゲートウェイ | アプリロジック | データ層 |
|--------|--------|---------|-----------|------------|
| 不正な入力 | ○ (UX) | ○ | ○ | - |
| 盗まれたセッション | - | ○ | ○ | ○ |
| IDOR（誤ったリソース） | - | - | ○ | ○ |
| SQL インジェクション | - | - | - | ○ |
| ブルートフォース | - | ○ | - | - |
| CSRF | - | ○ | - | - |

## BaaS プラットフォームへの適用

### Convex

```
UI 無効化ボタン（層1 - UX のみ）
       │
       ▼
Convex 引数検証（層2 - 型安全性）
       │
       ▼
ハンドラーでの認証 + 認可チェック（層3 - ビジネスロジック）
       │
       ▼
ctx.db 操作（層4 - Convex が管理）
```

### Next.js + データベース

```
フォーム検証（層1）
       │
       ▼
ミドルウェア認証チェック（層2）
       │
       ▼
Server Action: Zod 検証 + 認可（層3）
       │
       ▼
Data Access Layer と認可（層3.5）
       │
       ▼
パラメータ化クエリ / ORM（層4）
       │
       ▼
データベース（層5）
```

### Supabase

```
クライアントサイドチェック（層1）
       │
       ▼
Supabase Auth JWT 検証（層2）
       │
       ▼
Edge Function ロジック（層3）または
       │
       ▼
RLS ポリシー（層4） ← 直接アクセスの主な防御
       │
       ▼
PostgreSQL（層5）
```

### Firebase

```
クライアントサイドチェック（層1）
       │
       ▼
Firebase Auth（層2）
       │
       ▼
Security Rules（層4） ← 直接 Firestore アクセス用
       │
Cloud Functions と手動認証（層3） ← 複雑なロジック用
       │
       ▼
Admin SDK から Firestore（層4）
```

## 「スイスチーズ」モデル

各層を穴（脆弱性）のあるスイスチーズのスライスと考えてください。
複数のスライスを重ねると、穴が一直線に並ぶ可能性は低くなります。

```
  攻撃
    │
    ▼
┌───────────┐  層1: ここに穴、攻撃者が通過
│  ○   ○    │
└───────────┘
    │
    ▼
┌───────────┐  層2: ブロック！
│    ○   ○  │
│  ■        │  ← 攻撃停止
└───────────┘
```

層1にバグがあっても、層2がキャッチ。
両方が失敗しても、層3または層4が保護する可能性。

## 実践的な意味

1. **他の層が「キャッチするはず」だからといって層をスキップしない**
2. **各層は独立して動作すべき** - 前の層が実行されたと仮定しない
3. **各層でログを取る** - 攻撃がどこで止められているか特定するため
4. **各層を分離してテスト** - 上の層が失敗したらどうなる？
5. **最深層が最も重要** - データベースレベルの保護が最後の砦
