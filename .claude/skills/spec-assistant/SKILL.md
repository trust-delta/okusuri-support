---
name: spec-assistant
description: 新機能の仕様書を対話形式で作成、または既存仕様書を実装に合わせて更新する。プロジェクトのテンプレートに準拠し、一貫性のある仕様書を生成する。
---

# 仕様書作成アシスタント

## 目的

プロジェクトにおける機能仕様書やAPI仕様書を構造化して作成・更新し、**実装と仕様書の同期**を維持します。

## いつ使うか

以下のような場面で、このスキルを呼び出してください：

- **新機能の仕様書作成**: 「通知機能の仕様書を作りたい」
- **既存仕様書の更新**: 「グループ機能の実装を変更したので、仕様書を更新したい」
- **API仕様の文書化**: 「認証APIの仕様書を作成したい」
- **実装前の設計**: 「リマインダー機能の仕様を整理したい」
- **実装後の文書化**: 「実装した機能を仕様書に落とし込みたい」

## スキルが行うこと

1. **対話形式で情報収集**
   - 機能概要・目的のヒアリング
   - ユースケース・要件の洗い出し
   - データモデル・API設計の確認
   - UI/UX要件の整理

2. **構造化された仕様書の生成**
   - プロジェクト固有のテンプレートに準拠
   - 既存仕様書のスタイルを分析・学習
   - 必須セクションを網羅

3. **適切な配置と命名**
   - 機能仕様: `.context/specs/features/[feature-name].md`
   - API仕様: `.context/specs/api/[feature-name]-api.md`
   - kebab-case形式のファイル名

4. **軽量な整合性確認（オプション）**
   - 仕様書更新時に関連実装ファイル（2-5個程度）を確認
   - 明らかな乖離があれば指摘

## 実行時の動作

### 1. 初期化フェーズ

1. **現在日時の取得**
   ```bash
   ./scripts/get-date.sh
   ```
   - スクリプト: [get-date.sh](scripts/get-date.sh)
   - Bashツールを使用してJSTの日付を取得（YYYY年MM月DD日形式）
   - 仕様書の「最終更新」に使用

2. **テンプレートの読み込み**
   - `.context/specs/templates/feature.template.md` - 機能仕様テンプレート
   - `.context/specs/templates/api.template.md` - API仕様テンプレート
   - 必須セクション、フォーマット、構造を把握

3. **既存仕様書の参照**
   - `.context/specs/features/` から最新3-5件の仕様書を読み込み
   - スタイル、詳細度、記述パターンを学習
   - プロジェクト固有の書き方を把握

4. **関連実装の確認（該当する場合のみ）**
   - 既存仕様書を更新する場合、関連実装ファイルの確認を提案
   - ユーザーが希望する場合、2-5個程度の主要ファイルを読み込み
   - 明らかな乖離があれば指摘

### 2. 対話フェーズ

#### 仕様書タイプの選択

「どのタイプの仕様書を作成しますか？」
- **feature**: 機能仕様書（ユースケース、UI/UX、データモデル、ビジネスルール）
- **api**: API仕様書（Queries, Mutations, Actions、引数、戻り値）

#### 新規作成 or 更新の確認

「新規作成ですか、それとも既存仕様書の更新ですか？」
- **新規作成**: 対話で全情報を収集
- **更新**: 既存仕様書を読み込み、変更点のみヒアリング

#### 情報収集（仕様書タイプによって変動）

詳細は「対話フロー」セクション参照

### 3. 生成フェーズ

収集した情報をテンプレートに基づいて構造化

#### ファイル名の決定

機能名から自動的にkebab-case形式で生成：

**変換例**:
- 「通知機能」 → `notification.md`
- 「リマインダー設定」 → `reminder-settings.md`
- 「薬剤統計ダッシュボード」 → `medication-statistics-dashboard.md`

**命名ルール**:
- 英数字と `-` のみ使用
- すべて小文字
- スペースは `-` に変換
- 日本語は英訳してkebab-case化
- 略語は小文字に統一（例: `api`, `ui`）

#### 実装状況の設定

各機能要件に「実装状況」を付与：
- **未実装**: これから実装する機能（実装前の仕様書作成）
- **進行中**: 現在開発中の機能
- **完了**: 既に実装済みの機能（実装後の仕様書作成）

#### 関連ドキュメントの自動提案

仕様書の内容から関連しそうなドキュメントを自動検索・提案：

**検索対象**:
- `.context/` 配下のプロジェクトドキュメント
- 既存の仕様書・決定記録
- アーキテクチャドキュメント

**提案ロジック**:
- 機能名・API名のキーワードで検索
- 関連する技術スタック（Convex, Next.js等）
- データモデルで使用するテーブル

### 4. バリデーションフェーズ

生成した仕様書が以下の基準を満たしているか確認：

#### 機能仕様書（feature）

- [ ] 必須セクションがすべて含まれているか
  - 概要、ユースケース、機能要件、データモデル
- [ ] ファイル名がkebab-caseか
- [ ] 最終更新日が正しいか（YYYY年MM月DD日形式）
- [ ] データモデルがTypeScript形式で記述されているか
- [ ] 権限設計（RBAC）が記載されているか（該当する場合）

#### API仕様書（api）

- [ ] 必須セクションがすべて含まれているか
  - 概要、Queries/Mutations/Actions、データモデル
- [ ] ファイル名が`[feature-name]-api.md`形式か
- [ ] 各関数に引数・戻り値・エラーが記載されているか
- [ ] コード例がTypeScript形式で記述されているか

### 5. 出力フェーズ

適切なディレクトリに保存し、ユーザーに確認を促す：

- 機能仕様: `.context/specs/features/[feature-name].md`
- API仕様: `.context/specs/api/[feature-name]-api.md`

---

## 対話フロー

### 対話の柔軟性

**重要**: 以下のステップは推奨フローですが、ユーザーが既に十分な情報を提供している場合は該当ステップをスキップできます。

例:
- ユーザーが「通知機能の仕様書を作りたい。ユーザーが服薬時間になったらプッシュ通知を送る機能です」と詳細に説明した場合
  → 概要ステップをスキップし、不足情報のみ確認
- ユーザーが「この機能の仕様書を作りたい」とだけ言った場合
  → 全ステップを順番に実行

**判断基準**: ユーザーのメッセージから以下の情報が明確に読み取れる場合、該当ステップはスキップ可能
- 機能概要・目的
- ユースケース
- 主要な要件
- データモデル（該当する場合）

### 機能仕様書（feature）の対話フロー

#### ステップ1: 機能概要のヒアリング

「この機能の目的と価値を教えてください」
- 何を実現する機能か
- ユーザーにどんな価値を提供するか

#### ステップ2: ユースケースの整理

「主要なユースケースを教えてください」
- どんなシナリオで使われるか
- 誰が（patient/supporter）どのように使うか

#### ステップ3: 機能要件の確認

「具体的にどんな機能が必要ですか？」
- 必須機能（優先度: 高）
- あると便利な機能（優先度: 中・低）

#### ステップ4: データモデルの設計

「新しいテーブルやフィールドが必要ですか？」
- 新規テーブル定義
- 既存テーブルへのフィールド追加
- インデックス設計

#### ステップ5: UI/UX要件の確認

「画面構成や操作フローはどうなりますか？」
- 画面構成
- インタラクション
- フィードバック

#### ステップ6: 権限設計（該当する場合）

「この機能にロール別の権限が必要ですか？」
- patient/supporter別の操作可否
- 条件付き権限

### API仕様書（api）の対話フロー

#### ステップ1: API概要のヒアリング

「このAPIが提供する機能を教えてください」
- APIの目的
- 主要な操作

#### ステップ2: Queries（データ取得）の確認

「どんなデータ取得が必要ですか？」
- 関数名
- 引数・戻り値
- 認証要否

#### ステップ3: Mutations（データ更新）の確認

「どんなデータ更新が必要ですか？」
- 関数名
- 引数・戻り値
- バリデーションルール
- 副作用（作成・更新・削除するテーブル）

#### ステップ4: Actions（外部連携）の確認（該当する場合）

「外部APIとの連携が必要ですか？」
- 外部サービス名
- 処理フロー
- リトライ戦略

#### ステップ5: エラーハンドリングの確認

「想定されるエラーケースは？」
- 認証エラー
- バリデーションエラー
- ビジネスルールエラー

---

## 生成される仕様書の構成

### 機能仕様書（feature）

プロジェクトのテンプレート（`.context/specs/templates/feature.template.md`）に準拠して生成：

**主要セクション**:
- 概要（目的と価値提案）
- ユースケース（主要シナリオ）
- 機能要件（カテゴリ別、優先度・実装状況付き）
- データモデル（テーブル定義、ER図）
- ビジネスルール
- 権限設計（RBAC）
- API設計（概要、詳細は別ファイル）
- UI/UX要件（画面構成、インタラクション）
- バリデーション（フロントエンド・バックエンド）
- エラーハンドリング
- セキュリティ要件
- パフォーマンス要件
- テスト要件
- 依存関係
- マイルストーン
- 既知の課題
- 関連ドキュメント

### API仕様書（api）

プロジェクトのテンプレート（`.context/specs/templates/api.template.md`）に準拠して生成：

**主要セクション**:
- 概要
- Queries（データ取得）
  - 用途、認証、引数、戻り値、エラー、例
- Mutations（データ更新）
  - 用途、認証、引数、戻り値、バリデーション、副作用、エラー、例
- Actions（外部連携）
  - 用途、認証、引数、戻り値、処理フロー、リトライ、エラー、例
- 内部関数（Internal）
- データモデル
- 認可ルール
- ユースケース
- テストケース
- 関連ドキュメント

---

## 生成後の品質チェック

仕様書を生成した後、以下の項目をセルフチェックします：

### 必須項目チェックリスト

#### 機能仕様書（feature）

- [ ] **タイトル**: 機能名が簡潔に表現されているか
- [ ] **最終更新**: YYYY年MM月DD日形式で正しく記載されているか
- [ ] **概要**: 機能の目的と価値提案が2-3文で記述されているか
- [ ] **ユースケース**: 主要シナリオが最低1つ以上記載されているか
- [ ] **機能要件**: カテゴリ別に整理され、優先度・実装状況が記載されているか
- [ ] **データモデル**: TypeScript形式でテーブル定義が記述されているか
- [ ] **UI/UX要件**: 画面構成とインタラクションが記載されているか

#### API仕様書（api）

- [ ] **タイトル**: APIの対象機能が明確に表現されているか
- [ ] **最終更新**: YYYY年MM月DD日形式で正しく記載されているか
- [ ] **概要**: APIの提供機能が1-2文で説明されているか
- [ ] **関数定義**: 各関数に引数・戻り値・エラーが記載されているか
- [ ] **コード例**: TypeScript形式で実装例が記述されているか

### 品質基準チェック

- [ ] **具体性**: 抽象的な表現ではなく、具体的な実装方法が記載されているか
- [ ] **実装可能性**: 開発者がこの仕様書から実装を開始できるか
- [ ] **一貫性**: 既存の仕様書と矛盾していないか
- [ ] **完全性**: 他のチームメンバーが追加の質問なしで理解できるか

### 自動チェック項目

- [ ] ファイル名: `[feature-name].md` または `[feature-name]-api.md` 形式
- [ ] ファイルパス: `.context/specs/features/` または `.context/specs/api/` 配下
- [ ] 文字エンコーディング: UTF-8
- [ ] 改行コード: LF（Unix形式）

チェックで問題が見つかった場合、修正してから保存します。

---

## 既存仕様書の参照

このスキルは以下の既存仕様書を学習材料として参照します：

- `.context/specs/features/medication.md` - 服薬管理機能
- `.context/specs/features/group.md` - グループ管理機能
- `.context/specs/features/auth.md` - 認証機能
- `.context/specs/features/onboarding.md` - オンボーディング機能
- `.context/specs/features/medication-history.md` - 服薬履歴機能

これらのスタイル・構造・詳細度を参考に、一貫性のある仕様書を生成します。

---

## 関連コンテキスト

仕様書作成時に参照すべきプロジェクトドキュメント：

- `.context/project.md` - プロジェクト概要、技術スタック
- `.context/architecture.md` - アーキテクチャ全体像、データモデル
- `.context/coding-style.md` - コーディング規約（API設計パターン）
- `.context/error-handling.md` - エラーハンドリング戦略
- `.context/testing-strategy.md` - テスト戦略

---

## 軽量な整合性確認（オプション）

仕様書更新時に、関連する実装ファイルを確認できます：

### 確認タイミング

- 既存仕様書を更新する場合のみ提案
- ユーザーが希望する場合に実行

### 確認範囲

**最大2-5個の主要ファイルのみ**（大規模スキャンは行わない）

例:
- 機能仕様書更新時: `src/features/[feature]/components/`, `convex/[feature]/`
- API仕様書更新時: `convex/[feature]/queries.ts`, `convex/[feature]/mutations.ts`

### 確認内容

- 仕様書に記載されている関数・コンポーネントが実装に存在するか
- 引数・戻り値の型が一致しているか
- 明らかな乖離があれば指摘

### 大規模整合性チェックは範囲外

プロジェクト全体の仕様書と実装を網羅的にスキャンするのは、このスキルの範囲外です。
将来的に `context-validator` サブエージェントで対応予定。

---

## 注意事項

1. **実装との同期**: 仕様書と実装は常に同期すること（CLAUDE.mdの重要ルール）
2. **テンプレート準拠**: プロジェクト固有のテンプレートに100%準拠
3. **具体性**: 抽象的な記述ではなく、具体的な実装に言及
4. **実装可能性**: 開発者がこの仕様書から実装を開始できる詳細度
5. **日本語**: すべて日本語で記述（コードを除く）

---

## 使用例

### 例1: 新規機能仕様書の作成

```
ユーザー: 「通知機能の仕様書を作りたい」

アシスタント:
通知機能の仕様書を作成します。

[初期化フェーズ]
- 現在日時を取得: 2025年11月16日
- テンプレート読み込み: .context/specs/templates/feature.template.md
- 既存仕様書参照: 最新3件の仕様書を分析

いくつか質問させてください。

1. この機能の目的と価値を教えてください
2. 主要なユースケースは何ですか？
3. 必要な機能要件を教えてください

[対話を通じて情報収集]

[生成フェーズ]
仕様書を生成しています...

[バリデーションフェーズ]
- ✅ 必須セクション: 完備
- ✅ ファイル名: notification.md (kebab-case)
- ✅ データモデル: TypeScript形式で記述
- ✅ 具体性: 実装可能な詳細度

仕様書を作成しました：
📄 .context/specs/features/notification.md

内容を確認して、必要に応じて修正してください。
```

### 例2: 既存仕様書の更新

```
ユーザー: 「グループ機能の実装を変更したので、仕様書を更新したい。
グループ削除時にメンバー全員に通知を送るようにしました」

アシスタント:
グループ機能の仕様書を更新します。

[初期化フェーズ]
- 現在日時を取得: 2025年11月16日
- 既存仕様書読み込み: .context/specs/features/group.md
- 変更内容を確認

関連実装ファイルを確認しますか？（オプション）
→ src/features/group/components/
→ convex/groups/mutations.ts

ユーザー: 「はい」

[軽量整合性確認]
以下のファイルを確認しました：
- convex/groups/mutations.ts: deleteGroup関数を確認
- 通知送信処理が実装されていることを確認

確認した点：
1. グループ削除時にメンバー全員に通知が送信される
2. 通知内容: 「グループが削除されました」

この変更を仕様書に反映しますか？
- 機能要件セクションに「グループ削除時の通知」を追加
- API設計セクションのdeleteGroup関数の副作用に通知送信を記載

[生成フェーズ]
仕様書を更新しました：
📝 .context/specs/features/group.md
  - 最終更新: 2025年11月16日
  - 機能要件: グループ削除時の通知機能を追加
  - API設計: deleteGroup関数の副作用を更新
```

### 例3: API仕様書の作成

```
ユーザー: 「認証APIの仕様書を作成したい」

アシスタント:
認証APIの仕様書を作成します。

[初期化フェーズ]
- 現在日時を取得: 2025年11月16日
- テンプレート読み込み: .context/specs/templates/api.template.md
- 既存仕様書参照: API仕様書のスタイルを学習

いくつか質問させてください。

1. どんなデータ取得（Queries）が必要ですか？
   （例: ユーザー情報取得、セッション確認）
2. どんなデータ更新（Mutations）が必要ですか？
   （例: サインアップ、ログイン、ログアウト）
3. 外部連携（Actions）は必要ですか？
   （例: メール送信、OAuth連携）

[対話を通じて情報収集]

[生成フェーズ]
API仕様書を生成しています...

[バリデーションフェーズ]
- ✅ 必須セクション: 完備
- ✅ ファイル名: auth-api.md
- ✅ 関数定義: 引数・戻り値・エラーを記載
- ✅ コード例: TypeScript形式で記述

API仕様書を作成しました：
📄 .context/specs/api/auth-api.md
```

---

## このスキルの利点

✅ **実装との同期**: 仕様書と実装の乖離を防ぐ
✅ **一貫性**: プロジェクト全体で統一されたフォーマット
✅ **効率化**: 対話形式で詳細な仕様書を作成可能
✅ **品質保証**: 自動バリデーションで必須項目の漏れを防ぐ
✅ **柔軟な対話**: ユーザーの情報量に応じて質問をスキップ
✅ **正確な日時**: Bashツールでシステム日時を取得、手入力ミスを防止
✅ **命名の一貫性**: kebab-case変換ルールでファイル名の統一
✅ **実装可能な詳細度**: 開発者がすぐに実装を開始できる
✅ **軽量整合性確認**: 仕様書更新時に関連実装を確認可能
✅ **関連情報の提示**: 関連ドキュメントを自動提案

---

## プロジェクト固有のルール（CLAUDE.md参照）

- **仕様書と実装は常に同期していること**（最重要）
- 仕様書が存在しない機能を実装する場合は、まず仕様書の作成を提案すること
- 実装を変更した場合は、仕様書も即座に更新すること
- `.context/specs/` に記載された仕様に従うこと
